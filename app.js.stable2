document.addEventListener("DOMContentLoaded", () => {
  // 1) Define your constants up front
  const CONSTANTS = {
    detailPresets: {
      brief: {
        instruction: "Provide very brief reply straigh to the point.",
        tokens: 1024,
      },
      concise: {
        instruction: "Provide a concise reply with mentioning details.",
        tokens: 2048,
      },
      balanced: {
        instruction: "Provide a very balanced sized reply within 12 sentences.",
        tokens: 4096,
      },
      detailed: {
        instruction:
          "Provide a very detailed reply within 24 sentences and give explicit examples or sources of proof.",
        tokens: 7168,
      },
      context: {
        instruction:
          "Provide a very long, precise and contextual reply and give explicit examples or sources of proof.",
        tokens: 7168,
      },
    },
    apiEndpoint: "https://api.deepseek.com/v1/chat/completions",
    animationSettings: {
      buttonPress: [
        { transform: "scale(1)" },
        { transform: "scale(0.96)" },
        { transform: "scale(1)" },
      ],
      duration: 300,
    },
  };

  // 2) Load from local storage (if any)
  const savedState = loadAppState();

  // 3) Define a helper function that does NOT reference 'state'
  function getSystemPrompt(mode, userName = "", language = "english") {
    try {
      const namePart = userName
        ? ` The user's name is ${userName}. Please address them by name when appropriate.`
        : "";

      const languageMap = {
        english: "Always communicate in English unless...",
        german: "Antworte ab sofort immer auf Deutsch...",
      };

      // In loadUserProfile()
      const SUPPORTED_LANGUAGES = ["english", "german"];
      if (!SUPPORTED_LANGUAGES.includes(state.userProfile.language)) {
        state.userProfile.language = "english";
      }

      const languageInstruction = languageMap[language] || languageMap.english;

      const languageFallback = !state.userProfile?.language
        ? " IMPORTANT: The user hasn't set a preferred language. Ask them to configure it in their profile settings if language preferences are important for this conversation."
        : "";

      const prompts = {
        coding:
          "You are Aurora, an AI assistant specialized in creating, modifying, improving, and managing code. " +
          `You are a highly knowledgeable web app developer and frontend UI/UX designer.${namePart} ` +
          `${languageInstruction}${languageFallback}`,
        creative:
          "You are Aurora, an AI assistant specialized in creative tasks..." +
          `${namePart} ${languageInstruction}${languageFallback}`,
        judge:
          "You are Aurora, an AI assistant specialized in science, finance and legal advice..." +
          `${namePart} ${languageInstruction}${languageFallback}`,
      };
      return prompts[mode] || prompts.coding;
    } catch (error) {
      console.error("System prompt error:", error);
      return DEFAULT_SYSTEM_PROMPT;
    }
  }

  // 4) Define 'state' WITHOUT directly calling getSystemPrompt.
  const state = {
    currentMode: savedState?.currentMode || "coding",
    temperature: savedState?.temperature || 0.0,
    pendingMessages: new Map(),
    chatHistory: [],
    detailLevel: savedState?.detailLevel || "brief",
    currentModel: savedState?.currentModel || "deepseek-chat",
    isLoading: false,
    attachments: [],
    lastMessageTime: 0,
    userProfile: {}, // We’ll fill this later via loadUserProfile()
    uiElements: {
      modeButtons: document.querySelectorAll(".mode-pill"),
      chatContainer: document.getElementById("chatContainer"),
      chatPlaceholder: document.getElementById("chatPlaceholder"),
      userInput: document.getElementById("userInput"),
      sendBtn: document.getElementById("sendBtn"),
      modal: document.getElementById("confirmationModal"),
      modalConfirm: document.getElementById("modalConfirm"),
      modalCancel: document.getElementById("modalCancel"),
      fileUploadBtn: document.getElementById("fileUploadBtn"),
      fileInput: document.getElementById("fileInput"),
      detailPills: document.querySelectorAll(".detail-pill"),
      modelPills: document.querySelectorAll(".model-pill"),
    },
    constants: CONSTANTS,
  };

  // 5) Load user profile so we know the user’s name (if any)
  loadUserProfile(); // now state.userProfile is known
  // Apply the saved theme on page load
  loadThemePreference();

  // 6) Create or load chatHistory
  if (savedState?.chatHistory?.length) {
    // Use previously saved messages
    state.chatHistory = savedState.chatHistory;
  } else {
    // Brand new: create the system prompt with user name if available
    const userName = state.userProfile?.name || "";
    state.chatHistory = [
      {
        role: "system",
        content: `${getSystemPrompt("coding", userName)} ${
          CONSTANTS.detailPresets.brief.instruction
        }`,
      },
    ];
  }

  marked.setOptions({
    highlight: function (code, lang) {
      return hljs.highlightAuto(code).value;
    },
    langPrefix: "language-",
  });

  // 7) Continue your initialization
  renderChatHistory();
  updatePlaceholderVisibility();
  updateModeUI();
  updateDetailUI();
  updateModelUI();
  updateTemperature();

  // 8) Set up event listeners
  initializeEventHandlers();

  // 9) Handle user profile modal references
  const userProfileModal = document.getElementById("userProfileModal");
  const userProfileForm = document.getElementById("userProfileForm");
  const profileCancelBtn = document.getElementById("profileCancel");
  const userNameInput = document.getElementById("userName");
  const userLanguageSelect = document.getElementById("userLanguage");

  // Open user profile modal
  document.getElementById("userProfileBtn")?.addEventListener("click", () => {
    userNameInput.value = state.userProfile?.name || "";
    userLanguageSelect.value = state.userProfile?.language || "english"; // Set language
    userProfileModal.style.display = "flex";
  });
  // Cancel = close modal
  profileCancelBtn?.addEventListener("click", () => {
    userProfileModal.style.display = "none";
  });

  // Save user profile
  userProfileForm?.addEventListener("submit", (e) => {
    e.preventDefault();
    const name = userNameInput.value.trim();
    const language = userLanguageSelect.value;

    if (name) {
      state.userProfile.name = name;
      state.userProfile.language = language;
      localStorage.setItem("userProfile", JSON.stringify(state.userProfile));

      // Update system prompt with new language
      state.chatHistory[0].content = `${getSystemPrompt(
        state.currentMode,
        state.userProfile.name,
        state.userProfile.language
      )} ${state.constants.detailPresets[state.detailLevel].instruction}`;
    }
    userProfileModal.style.display = "none";
  });

  // Main event listeners
  function initializeEventHandlers() {
    state.uiElements.fileUploadBtn?.addEventListener("click", () =>
      state.uiElements.fileInput.click()
    );
    state.uiElements.fileInput?.addEventListener("change", handleFileUpload);
    state.uiElements.modeButtons.forEach((btn) =>
      btn.addEventListener("click", () => handleModeChange(btn))
    );
    state.uiElements.detailPills.forEach((btn) =>
      btn.addEventListener("click", () => handleDetailChange(btn))
    );
    state.uiElements.modelPills.forEach((btn) =>
      btn.addEventListener("click", () => handleModelChange(btn))
    );
    state.uiElements.sendBtn?.addEventListener("click", sendMessage);
    state.uiElements.userInput?.addEventListener("input", () => {
      autoExpand(state.uiElements.userInput);
    });
    state.uiElements.userInput?.addEventListener(
      "keydown",
      handleInputKeypress
    );
    document.getElementById("newChatBtn")?.addEventListener("click", showModal);
    state.uiElements.modalConfirm?.addEventListener("click", confirmNewChat);
    state.uiElements.modalCancel?.addEventListener("click", hideModal);
    window.addEventListener("click", handleWindowClick);
    document.addEventListener("keydown", handleEscapeKey);
  }

  // Switch modes
  function handleModeChange(button) {
    state.uiElements.modeButtons.forEach((btn) => {
      btn.classList.remove("active");
      btn.removeAttribute("aria-current");
    });
    button.classList.add("active");
    button.setAttribute("aria-current", "true");
    state.currentMode = button.dataset.mode;

    // Update system prompt
    const userName = state.userProfile?.name || "";
    state.chatHistory[0] = {
      role: "system",
      content: `${getSystemPrompt(state.currentMode, userName)} ${
        state.constants.detailPresets[state.detailLevel].instruction
      }`,
    };

    updateTemperature();
    animateElement(button);
    saveAppState();
  }

  // Switch detail levels
  function handleDetailChange(button) {
    state.uiElements.detailPills.forEach((btn) => {
      btn.classList.remove("active");
      btn.removeAttribute("aria-current");
    });
    button.classList.add("active");
    button.setAttribute("aria-current", "true");
    state.detailLevel = button.dataset.detail;

    const userName = state.userProfile?.name || "";
    state.chatHistory[0].content = `${getSystemPrompt(
      state.currentMode,
      userName
    )} ${state.constants.detailPresets[state.detailLevel].instruction}`;

    animateElement(button);
    saveAppState();
  }

  // Switch models
  function handleModelChange(button) {
    state.uiElements.modelPills.forEach((btn) => {
      btn.classList.remove("active");
      btn.removeAttribute("aria-current");
    });
    button.classList.add("active");
    button.setAttribute("aria-current", "true");
    state.currentModel = button.dataset.model;
    animateElement(button);
    saveAppState();
  }

  // File upload
  async function handleFileUpload(e) {
    const files = e.target.files;
    if (!files?.length) return;

    const allowedTypes = [
      "text/plain", // .txt
      "image/jpeg", // .jpg, .jpeg
      "image/png", // .png
      "text/markdown", // .md (some systems may use text/x-markdown)
      "text/html", // .html
      "application/javascript", // .js
      "application/x-javascript",
      "text/css", // .css
      "application/x-php", // .php (alternative: text/x-php)
      "text/x-python", // .py (alternative: application/x-python)
    ];

    try {
      for (const file of files) {
        if (!allowedTypes.includes(file.type)) {
          throw new Error(`Unsupported file type: ${file.type}`);
        }
        if (file.size > 512 * 1024) {
          throw new Error(`${file.name} exceeds 512KB limit`);
        }
        const content = await readFileContent(file);
        state.attachments.push({
          name: file.name,
          type: file.type,
          content,
        });
      }
      updateAttachmentPreviews();
      updatePlaceholderVisibility();
    } catch (error) {
      addMessage(`File upload failed: ${error.message}`, "error");
      updatePlaceholderVisibility();
    }
    e.target.value = "";
  }

  // Prepare messages for 'deepseek-reasoner'
  function prepareMessagesForModel() {
    if (state.currentModel === "deepseek-reasoner") {
      const systemMsg = state.chatHistory.find((m) => m.role === "system");
      // find the last user message
      const lastUserMsg = [...state.chatHistory]
        .reverse()
        .find((m) => m.role === "user");
      const result = [];
      if (systemMsg) result.push(systemMsg);
      if (lastUserMsg) result.push(lastUserMsg);
      return result;
    }
    return state.chatHistory;
  }

  // Send user message → AI
  async function sendMessage() {
    const messageContent = state.uiElements.userInput.value.trim();
    if (!messageContent || state.isLoading) return;

    const currentTime = Date.now();
    if (currentTime - state.lastMessageTime < 1000) return; // throttle
    state.lastMessageTime = currentTime;

    const currentMode = state.currentMode;
    const currentDetailLevel = state.detailLevel;
    const currentModel = state.currentModel;

    // Build user message
    const messagePayload = {
      text: messageContent,
      attachments: state.attachments.map((att) => ({
        name: att.name,
        type: att.type,
        content: att.content,
      })),
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      settings: {
        mode: currentMode,
        detailLevel: currentDetailLevel,
        model: currentModel,
      },
    };

    // Append user message to chat
    state.chatHistory.push({ role: "user", content: messageContent });
    addMessage(
      messageContent,
      "user",
      null,
      messagePayload.id,
      messagePayload.settings,
      true
    );

    // Remember where to place AI message
    const userMessageElement = state.uiElements.chatContainer.lastElementChild;
    state.pendingMessages.set(messagePayload.id, {
      element: userMessageElement,
      settings: messagePayload.settings,
    });

    // If attachments exist, embed references
    if (messagePayload.attachments.length > 0) {
      messagePayload.text += "\n\n[Attachments]";
      messagePayload.attachments.forEach((att) => {
        messagePayload.text += `\nFILE: ${att.name}\n${att.content}\n`;
      });
    }

    // Clear input
    state.uiElements.userInput.value = "";
    requestAnimationFrame(() => autoExpand(state.uiElements.userInput));
    state.attachments = [];
    updateAttachmentPreviews();

    // Send API request
    try {
      state.isLoading = true;
      showLoading();
      const response = await fetch(state.constants.apiEndpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          // Remove or replace with your own token if needed
          Authorization: `Bearer ${CONFIG.API_KEY}`,
        },
        body: JSON.stringify({
          model: currentModel,
          messages: prepareMessagesForModel(),
          temperature: state.temperature,
          max_tokens: state.constants.detailPresets[currentDetailLevel].tokens,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          `API error: ${response.status} - ${
            errorData.error?.message || "Unknown error"
          }`
        );
      }

      const responseText = await response.text();
      let data;
      try {
        data = JSON.parse(responseText);
      } catch {
        throw new Error("Invalid JSON response from server");
      }

      const aiResponse =
        data.choices[0]?.message?.content || "No response received";
      addMessage(
        aiResponse,
        "ai",
        null,
        messagePayload.id,
        messagePayload.settings,
        false
      );
      state.chatHistory.push({ role: "assistant", content: aiResponse });
    } catch (error) {
      addMessage(`Error: ${error.message}`, "error");
      state.pendingMessages.delete(messagePayload.id);
    } finally {
      state.isLoading = false;
      hideLoading();
      saveAppState();
    }
  }

  // Add message to DOM
  function addMessage(
    content,
    type,
    insertAfter = null,
    messageId = null,
    settings = null,
    skipTyping = false
  ) {
    const frag = new DocumentFragment();
    const messageDiv = document.createElement("div");
    messageDiv.className = `message ${type}-message`;

    if (messageId && type === "user") {
      messageDiv.dataset.messageId = messageId;
    }

    // We don’t rely on 'state' here, we use the settings object or fallback
    const modeLabel = settings?.mode || state.currentMode;
    const detailLabel = settings?.detailLevel || state.detailLevel;
    const modelLabel = settings?.model || state.currentModel;

    // In the addMessage function's messageDiv.innerHTML template:
    messageDiv.innerHTML = `
    <div class="message-header">
      <span class="message-username">
        ${
          type === "user"
            ? `${
                state.userProfile?.name
                  ? state.userProfile.name + " (You)"
                  : "You"
              }`
            : `Aurora → ${modeLabel} → ${modelLabel} → ${detailLabel}`
        }
      </span>
      <span class="message-timestamp" data-timestamp="${new Date().toISOString()}">
        ${getTimeAgo(new Date())}
      </span>
    </div>
    <span class="message-content"></span>
      `;

    const contentElement = messageDiv.querySelector(".message-content");

    if (type === "user" || type === "error") {
      contentElement.innerHTML =
        type === "error"
          ? DOMPurify.sanitize(content)
          : marked.parse(DOMPurify.sanitize(content));
    } else if (type === "ai") {
      messageDiv.classList.add("typing");
      if (skipTyping) {
        contentElement.innerHTML = marked.parse(DOMPurify.sanitize(content));

        messageDiv.classList.remove("typing");
      } else {
        typeText(contentElement, content, () => {
          contentElement.innerHTML = marked.parse(DOMPurify.sanitize(content));
          // Highlighting already handled in typeText
          messageDiv.classList.remove("typing");
        });
      }
    }

    frag.appendChild(messageDiv);

    if (type === "user") {
      state.uiElements.chatContainer.appendChild(frag);
      updatePlaceholderVisibility();
    } else if (type === "ai" && messageId) {
      // Insert after the user message
      const targetElement = state.pendingMessages.get(messageId)?.element;
      if (targetElement) {
        targetElement.after(frag);
        state.pendingMessages.delete(messageId);
        return;
      }
    } else if (insertAfter) {
      insertAfter.after(frag);
    } else {
      state.uiElements.chatContainer.appendChild(frag);
    }

    scrollToBottomIfNeeded();

    // Auto-scroll if near bottom
    const container = state.uiElements.chatContainer;
    const threshold = 100;
    const scrollBottom =
      container.scrollHeight - container.scrollTop - container.clientHeight;
    if (scrollBottom <= threshold) {
      container.scrollTop = container.scrollHeight;
    }
  }

  // Delete Message
  function deleteMessage(messageElement) {
    messageElement.remove();
    saveChatHistory();
    updatePlaceholderVisibility(); // Ensure placeholder is restored if chat is empty
  }

  // Re-render entire chat
  function renderChatHistory() {
    // Clear existing chat content
    state.uiElements.chatContainer.innerHTML = "";

    // Null check for chat placeholder element
    if (!state.uiElements.chatPlaceholder) {
      console.error("chatPlaceholder element not found in DOM");
      return;
    }

    // Determine if we should show the placeholder
    const hasMessages = state.chatHistory.some(
      (msg) => msg.role === "user" || msg.role === "assistant"
    );

    // Toggle placeholder visibility and DOM presence
    if (!hasMessages) {
      state.uiElements.chatContainer.appendChild(
        state.uiElements.chatPlaceholder
      );
      state.uiElements.chatPlaceholder.style.display = "flex";
      return; // Exit early since there are no messages to render
    } else {
      state.uiElements.chatPlaceholder.style.display = "none";
    }

    // Render messages with proper associations
    let lastUserElement = null;
    state.chatHistory.forEach((msg) => {
      if (msg.role === "system") return;

      if (msg.role === "user") {
        addMessage(msg.content, "user", null, null, null, true);
        lastUserElement = state.uiElements.chatContainer.lastElementChild;
      } else if (msg.role === "assistant") {
        addMessage(msg.content, "ai", lastUserElement, null, null, true);
      }
    });

    scrollToBottomIfNeeded(true);
  }

  function updatePlaceholderVisibility() {
    const hasMessages = document.querySelectorAll(".message").length > 0;
    if (state.uiElements.chatPlaceholder) {
      state.uiElements.chatPlaceholder.style.display = hasMessages
        ? "none"
        : "flex";
    } else {
      console.warn("chatPlaceholder element is missing in the DOM");
    }
  }

  // Auto-expand textarea
  function autoExpand(field) {
    const MIN_HEIGHT = 52;
    field.style.height = "auto";
    const computed = window.getComputedStyle(field);
    const maxH = parseFloat(computed.maxHeight) || 9999;
    const naturalH = Math.max(field.scrollHeight, MIN_HEIGHT);
    field.style.height = `${Math.min(naturalH, maxH)}px`;
    field.style.overflowY = naturalH >= maxH ? "auto" : "hidden";
  }

  // Typewriter effect
  function typeText(
    element,
    rawText,
    onComplete,
    charsPerTick = 1,
    delay = 24
  ) {
    let index = 0;
    let tempBuffer = "";
    const length = rawText.length;

    function typeChunk() {
      if (index < length) {
        tempBuffer += rawText.slice(index, index + charsPerTick);
        const sanitized = DOMPurify.sanitize(tempBuffer);
        // Use parseInline to avoid block-level elements
        element.innerHTML = marked.parseInline(sanitized);

        // Remove previous cursor
        const oldCursor = element.querySelector(".fake-cursor");
        if (oldCursor) oldCursor.remove();

        // Create new cursor
        const cursor = document.createElement("span");
        cursor.className = "fake-cursor";
        cursor.textContent = "▋"; /* ▋ */

        // Insert cursor at the end using Range API
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(element);
        range.collapse(false); // Collapse to end
        range.insertNode(cursor);
        range.detach();

        index += charsPerTick;
        setTimeout(typeChunk, delay);
      } else {
        // Final render with full content
        element.innerHTML = marked.parse(DOMPurify.sanitize(rawText));

        const finalCursor = element.querySelector(".fake-cursor");
        if (finalCursor) finalCursor.remove();
        if (typeof onComplete === "function") onComplete();
      }
    }
    typeChunk();
  }

  // Update timestamps every 5 seconds
  setInterval(updateRelativeTimestamps, 5000);
  function updateRelativeTimestamps() {
    document.querySelectorAll(".message-timestamp").forEach((el) => {
      const ts = new Date(el.dataset.timestamp);
      el.textContent = getTimeAgo(ts);
    });
  }

  // Show file attachments in the UI
  function updateAttachmentPreviews() {
    const container = document.getElementById("attachmentPreviews");
    if (!container) return;
    container.innerHTML = "";
    state.attachments.forEach((attachment, idx) => {
      const preview = document.createElement("div");
      preview.className = "attachment-preview";
      preview.innerHTML = `
        <span>${attachment.name}</span>
        <button onclick="removeAttachment(${idx})">
          <i class="fas fa-times"></i>
        </button>
      `;
      container.appendChild(preview);
    });
  }

  // Remove file attachments
  window.removeAttachment = function (index) {
    state.attachments.splice(index, 1);
    updateAttachmentPreviews();
  };

  // Modal flow
  function showModal() {
    state.uiElements.modal.style.display = "flex";
  }
  function hideModal() {
    state.uiElements.modal.style.display = "none";
  }

  function confirmNewChat() {
    hideModal();
    localStorage.removeItem("appState");

    // Reset chat history
    state.chatHistory = [];

    // Clear UI before rebuilding system prompt
    state.uiElements.chatContainer.innerHTML = "";
    state.uiElements.chatContainer.appendChild(
      state.uiElements.chatPlaceholder
    );

    updatePlaceholderVisibility(); // Ensure placeholder is shown immediately

    // Reset system prompt and state
    const userName = state.userProfile?.name || "";
    state.chatHistory.push({
      role: "system",
      content: `${getSystemPrompt("coding", userName)} ${
        state.constants.detailPresets[state.detailLevel].instruction
      }`,
    });

    state.currentMode = "coding";
    state.detailLevel = "brief";
    state.currentModel = "deepseek-chat";
    state.temperature = 0.0;

    resetModeButtons();
    updateDetailUI();
    updateAttachmentPreviews();
    autoExpand(state.uiElements.userInput);
  }

  function resetModeButtons() {
    state.uiElements.modeButtons.forEach((btn) => {
      btn.classList.remove("active");
      btn.removeAttribute("aria-current");
    });
    const codingBtn = document.querySelector('.mode-pill[data-mode="coding"]');
    if (codingBtn) {
      codingBtn.classList.add("active");
      codingBtn.setAttribute("aria-current", "true");
      animateElement(codingBtn);
    }
  }

  function updateModeUI() {
    state.uiElements.modeButtons.forEach((btn) => {
      btn.classList.remove("active");
      btn.removeAttribute("aria-current");
      if (btn.dataset.mode === state.currentMode) {
        btn.classList.add("active");
        btn.setAttribute("aria-current", "true");
      }
    });
  }

  function updateDetailUI() {
    state.uiElements.detailPills.forEach((btn) => {
      btn.classList.remove("active");
      btn.removeAttribute("aria-current");
      if (btn.dataset.detail === state.detailLevel) {
        btn.classList.add("active");
        btn.setAttribute("aria-current", "true");
      }
    });
  }

  function updateModelUI() {
    state.uiElements.modelPills.forEach((btn) => {
      btn.classList.remove("active");
      btn.removeAttribute("aria-current");
      if (btn.dataset.model === state.currentModel) {
        btn.classList.add("active");
        btn.setAttribute("aria-current", "true");
      }
    });
  }

  function handleWindowClick(e) {
    if (e.target === state.uiElements.modal) hideModal();
  }
  function handleEscapeKey(e) {
    if (e.key === "Escape") {
      if (state.uiElements.modal.style.display === "flex") {
        hideModal();
      }
      const userProfileModal = document.getElementById("userProfileModal");
      if (userProfileModal && userProfileModal.style.display === "flex") {
        userProfileModal.style.display = "none";
      }
    }
  }
  function handleInputKeypress(e) {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  }

  // Animate button
  function animateElement(element) {
    element.animate(state.constants.animationSettings.buttonPress, {
      duration: state.constants.animationSettings.duration,
      easing: "ease-out",
    });
  }

  // Adjust temperature by mode
  function updateTemperature() {
    switch (state.currentMode) {
      case "creative":
        state.temperature = 1.2;
        break;
      case "judge":
        state.temperature = 0.3;
        break;
      default:
        state.temperature = 0.0;
    }
  }

  // Loading spinner
  function showLoading() {
    const loading = document.createElement("div");
    loading.className = "loading";
    loading.innerHTML = `
      <span>Aurora is thinking</span>
      <div class="loading-dots">
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
      </div>
    `;
    const container = state.uiElements.chatContainer;
    container.appendChild(loading);

    const threshold = 100;
    const scrollBottom =
      container.scrollHeight - container.scrollTop - container.clientHeight;
    if (scrollBottom <= threshold) {
      container.scrollTop = container.scrollHeight;
    }
  }

  function hideLoading() {
    const loading = document.querySelector(".loading");
    if (loading) loading.remove();
  }

  // Time-ago display
  function getTimeAgo(date) {
    const intervals = {
      year: 525600,
      month: 43800,
      week: 10080,
      day: 1440,
      hour: 60,
      minute: 1,
    };
    const diff = Math.floor((Date.now() - date) / 60000);
    for (const [unit, unitVal] of Object.entries(intervals)) {
      const interval = Math.floor(diff / unitVal);
      if (interval >= 1) {
        return `${interval} ${unit}${interval > 1 ? "s" : ""} ago`;
      }
    }
    return "Just now";
  }

  // Read file content as text or dataURL
  async function readFileContent(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        if (file.type.startsWith("image/")) {
          resolve(`![Uploaded Image](${e.target.result})`);
        } else {
          resolve(
            `**Uploaded File (${file.name}):**\n\`\`\`\n${e.target.result}\n\`\`\``
          );
        }
      };
      reader.onerror = reject;
      if (file.type.startsWith("image/")) {
        reader.readAsDataURL(file);
      } else {
        reader.readAsText(file);
      }
    });
  }

  // Save state
  function saveAppState() {
    const dataToSave = {
      chatHistory: state.chatHistory,
      currentMode: state.currentMode,
      detailLevel: state.detailLevel,
      currentModel: state.currentModel,
      temperature: state.temperature,
    };
    localStorage.setItem("appState", JSON.stringify(dataToSave));
  }

  // Load from localStorage
  function loadAppState() {
    try {
      const stored = localStorage.getItem("appState");
      return stored ? JSON.parse(stored) : null;
    } catch (err) {
      console.warn("Failed to parse saved state:", err);
      return null;
    }
  }

  // Save theme preference to localStorage
  function saveThemePreference(isDarkMode) {
    localStorage.setItem("themePreference", isDarkMode ? "dark" : "light");
  }

  // Load theme preference from localStorage
  function loadThemePreference() {
    const savedTheme = localStorage.getItem("themePreference");
    const htmlElement = document.documentElement;

    if (savedTheme === "dark") {
      htmlElement.setAttribute("data-theme", "dark");
    } else {
      htmlElement.setAttribute("data-theme", "light");
    }
  }

  // Toggle theme
  document.getElementById("themeToggleBtn")?.addEventListener("click", () => {
    const htmlElement = document.documentElement;
    const currentTheme = htmlElement.getAttribute("data-theme");
    const newTheme = currentTheme === "dark" ? "light" : "dark";

    htmlElement.setAttribute("data-theme", newTheme);
    saveThemePreference(newTheme === "dark");
  });

  // Load user profile
  // Update loadUserProfile function
  function loadUserProfile() {
    try {
      const storedProfile = localStorage.getItem("userProfile");
      if (storedProfile) {
        state.userProfile = JSON.parse(storedProfile);
        // Set default language if not present
        if (!state.userProfile.language) {
          state.userProfile.language = "english";
        }
      } else {
        state.userProfile = { language: "english" };
      }
    } catch (err) {
      console.warn("Failed to parse user profile:", err);
      state.userProfile = { language: "english" };
    }
  }

  // Update Mode UI
  function updateModeUI() {
    // Remove active state from all mode buttons
    state.uiElements.modeButtons.forEach((btn) => {
      btn.classList.remove("active");
      btn.removeAttribute("aria-current");
    });

    // Add active state to the button matching the current mode
    const currentMode = state.currentMode; // e.g. "coding", "creative", or "judge"
    state.uiElements.modeButtons.forEach((btn) => {
      if (btn.dataset.mode === currentMode) {
        btn.classList.add("active");
        btn.setAttribute("aria-current", "true");
      }
    });
  }

  function loadChatHistory() {
    const savedMessages = JSON.parse(localStorage.getItem("chatHistory")) || [];
    const chatContainer = document.getElementById("chatContainer");

    chatContainer.innerHTML = ""; // Clear existing content before loading
    if (savedMessages.length === 0) {
      if (typeof updatePlaceholderVisibility === "function") {
        updatePlaceholderVisibility(); // Ensure placeholder is shown if chat is empty
      } else {
        console.warn("updatePlaceholderVisibility function is not defined");
      }
      return;
    }

    savedMessages.forEach((msg) => {
      const messageElement = document.createElement("div");
      messageElement.classList.add(
        "chat-message",
        msg.role === "user" ? "user-message" : "assistant-message"
      );
      messageElement.textContent = msg.content;
      chatContainer.appendChild(messageElement);
    });

    saveChatHistory();

    if (typeof updatePlaceholderVisibility === "function") {
      updatePlaceholderVisibility(); // Ensure the placeholder is hidden if messages exist
    } else {
      console.warn("updatePlaceholderVisibility function is not defined");
    }
  }
  function saveChatHistory() {
    const messages = Array.from(document.querySelectorAll(".chat-message")).map(
      (msg) => ({
        role: msg.classList.contains("user-message") ? "user" : "assistant",
        content: msg.textContent.trim(),
      })
    );
    localStorage.setItem("chatHistory", JSON.stringify(messages));
    saveAppState(); // Use the existing state-based saving
    updatePlaceholderVisibility();
  }

  // Add this utility function to handle scroll logic
  function scrollToBottomIfNeeded(force = false) {
    const container = state.uiElements.chatContainer;
    if (!container) return;

    // Use requestAnimationFrame for smooth scrolling
    requestAnimationFrame(() => {
      if (force || isNearBottom(container)) {
        container.scrollTop = container.scrollHeight;
      }
    });
  }

  function isNearBottom(container, threshold = 100) {
    return (
      container.scrollHeight - container.scrollTop - container.clientHeight <=
      threshold
    );
  }
});
